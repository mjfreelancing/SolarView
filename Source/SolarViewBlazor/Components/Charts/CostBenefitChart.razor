<div class="d-flex">
  <button class="ml-auto" @onclick="DeleteChart">Remove</button>
</div>
<div class="p-1">
  <SfCheckBox Label="Cumulative" @bind-Checked="@_cumulativeMode" OnClick="@CalculateChartData" />
</div>
<div>
  <SfChart Title=@($"Period: {ChartData.StartDate:yyyy-MM-dd} to {ChartData.EndDate:yyyy-MM-dd}")>
    <ChartArea>
      <ChartAreaBorder Width="1" />
    </ChartArea>

    <ChartPrimaryXAxis ValueType="Syncfusion.Blazor.Charts.ValueType.Category" LabelFormat="{value}"
                       IntervalType="IntervalType.Auto" EdgeLabelPlacement="EdgeLabelPlacement.Shift" />

    <ChartPrimaryYAxis Minimum=@_minCost Maximum=@_maxCost Interval="@_interval" LabelFormat="c" />

    <ChartTooltipSettings Enable="true" />

    <ChartSeriesCollection>
      <ChartSeries DataSource=@_costData Name="Without Solar" Type="ChartSeriesType.Line" Width="2" Fill="#640000"
                   XName=@nameof(PowerCost.Time) YName=@nameof(PowerCost.WithoutSolarCost) />

      <ChartSeries DataSource=@_costData Name="With Solar" Type="ChartSeriesType.Line" Width="2" Fill="#006400"
                   XName=@nameof(PowerCost.Time) YName=@nameof(PowerCost.WithSolarCost) />
    </ChartSeriesCollection>
    <ChartLegendSettings Visible="true" />
  </SfChart>
</div>

@code {

  [CascadingParameter] public ChartContainer Parent { get; set; }
  [Parameter] public ChartData ChartData { get; set; }

  private class PowerCost
  {
    private double PurchaseCostPerW = 0.3283379d / 1000.0d;
    private double FeedInCostPerW = 0.105d / 1000.0d;
    private double FixedCostPerQuarterHour = 0.99d / 24.0d / 4.0d;

    public string Time { get; }
    public double WithSolarCost { get; }
    public double WithoutSolarCost { get; }

    public PowerCost(PowerData powerData)
    {
      Time = powerData.Time;
      WithSolarCost = FixedCostPerQuarterHour + (powerData.WattHour.Purchased * PurchaseCostPerW - powerData.WattHour.FeedIn * FeedInCostPerW);
      WithoutSolarCost = FixedCostPerQuarterHour + ((powerData.WattHour.Purchased + powerData.WattHour.SelfConsumption) * PurchaseCostPerW);
    }
  }

  private double _minCost;
  private double _maxCost;
  private double _interval;
  private bool _cumulativeMode;
  private IReadOnlyList<PowerCost> _costData;

  protected override void OnParametersSet()
  {
    base.OnParametersSet();

    if (Parent == null)
    {
      throw new InvalidOperationException($"The {nameof(Parent)} parameter must be initialized");
    }

    if (ChartData?.Power == null)
    {
      throw new InvalidOperationException($"The {nameof(ChartData)} parameter must be initialized with power data");
    }

    CalculateChartData();
  }

  private void CalculateChartData()
  {
    if (_cumulativeMode)
    {
      var costData = new List<PowerCost>();
      var lastPowerItem = default(PowerData);

      foreach (var powerData in ChartData.Power)
      {
        if (lastPowerItem == default)
        {
          lastPowerItem = new PowerData
          {
            Time = powerData.Time,
            WattHour = powerData.WattHour
          };
        }
        else
        {
          lastPowerItem.Time = powerData.Time;
          lastPowerItem.WattHour = WattsDataHelpers.Aggregate(lastPowerItem.WattHour, powerData.WattHour);
        }

        costData.Add(new PowerCost(lastPowerItem));
      }

      _costData = costData;
    }
    else
    {
      _costData = ChartData.Power
        .Select(item => new PowerCost(item))
        .ToList();
    }

    CalculateChartLimits();
  }

  private void CalculateChartLimits()
  {
    var minCost = _costData.Min(item => item.WithSolarCost);
    var maxCost = _costData.Max(item => item.WithoutSolarCost);

    var range = maxCost - minCost;
    var scalingFactor = range < 1.0d ? 100 : 1;

    if (minCost > 0.0d)
    {
      _minCost = (Math.Floor(minCost * scalingFactor) - 0.5d) / scalingFactor;
    }
    else
    {
      _minCost = (-Math.Ceiling(-minCost * scalingFactor) - 0.5d) / scalingFactor;
    }

    _maxCost = (Math.Ceiling(maxCost * scalingFactor) + 0.5d) / scalingFactor;

    _interval = (_maxCost - _minCost) / 8;
  }

  private async Task DeleteChart()
  {
    await Parent.DeleteChart(ChartData.Id);
  }
}
