@foreach (var chartParameters in OrderedCharts)
{
  var chartId = chartParameters.ChartData.Id;

  <div @key="chartId">
    <SfAccordion>
      <AccordionItems>
        <AccordionItem CssClass="chart-accordion-item" Expanded="true">
          <HeaderTemplate>
            <div class="col col-12 d-flex">
              <span>@($"{chartParameters.ChartData.StartDate:yyyy-MM-dd}") - @($"{chartParameters.ChartData.EndDate:yyyy-MM-dd}")</span>
              <span class="oi oi-delete m-0 mt-1 ml-auto mr-4" @onclick="@(async () => await DeleteChart(chartId))" />
            </div>
          </HeaderTemplate>
          <ContentTemplate>
            <DynamicComponent ComponentType="@ChartDescriptor.ChartType" Parameters="@(chartParameters.Parameters)" />
          </ContentTemplate>
        </AccordionItem>
      </AccordionItems>
    </SfAccordion>
  </div>
}

<style>

  .chart-accordion-item .e-acrdn-header-content {
    width: 100%
  }

</style>

@code {
  [Parameter] public IChartDescriptor ChartDescriptor { get; set; }
  [Parameter] public IReadOnlyList<ChartData> ChartData { get; set; }
  [Parameter] public EventCallback<string> ChartDeleted { get; set; }

  private class ChartParameters
  {
    public ChartData ChartData { get; }   // mostly used for adding the charts in date order
    public IDictionary<string, object> Parameters { get; }

    public ChartParameters(ChartData chartData, IDictionary<string, object> parameters)
    {
      ChartData = chartData;

      Parameters = new Dictionary<string, object>(parameters)
      {
        {nameof(ChartData), chartData}
      };
    }
  }

  private IReadOnlyList<ChartData> _chartData;
  private readonly IDictionary<string, ChartParameters> _renderedCharts = new Dictionary<string, ChartParameters>();

  private IEnumerable<ChartParameters> OrderedCharts => _renderedCharts.Values
    .OrderBy(item => item.ChartData.StartDate)
    .ThenBy(item => item.ChartData.EndDate);

  protected override void OnParametersSet()
  {
    base.OnParametersSet();

    // Cannot use OnInitialized() as ChartData will be updated when another chart is added/removed
    UpdateCharts();
  }

  private void UpdateCharts()
  {
    _chartData = ChartData;

    foreach (var chartData in _chartData)
    {
      if (!_renderedCharts.ContainsKey(chartData.Id))
      {
        AddChart(chartData);
      }
    }
  }

  private void AddChart(ChartData chartData)
  {
    var chartParameters = new ChartParameters(chartData, ChartDescriptor.Parameters);

    _renderedCharts.Add(chartData.Id, chartParameters);
  }

  public async Task DeleteChart(string chartId)
  {
    // remove the fragment associated with the chart Id
    _renderedCharts.Remove(chartId);

    // notify the parent
    await ChartDeleted.InvokeAsync(chartId);
  }
}
