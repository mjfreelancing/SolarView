<CascadingValue Value="this">

  @foreach (var chartFragment in _chartFragments.Values)
  {
    @*Cascading: ChartContainer*@
    @chartFragment
  }

</CascadingValue>

@code {
  [Inject] IChartFactory ChartFactory { get; set; }
  [Parameter] public IChartDescriptor ChartDescriptor { get; set; }
  [Parameter] public IReadOnlyList<ChartData> ChartData { get; set; }
  [Parameter] public EventCallback<string> ChartDeleted { get; set; }

  private readonly IDictionary<string, RenderFragment> _chartFragments = new Dictionary<string, RenderFragment>();

  protected override void OnParametersSet()
  {
    base.OnParametersSet();

    foreach (var chartData in ChartData)
    {
      // when another chart is added we need to make sure only the new item is added to the DOM (and hence _chartFragments)
      if (!_chartFragments.ContainsKey(chartData.Id))
      {
        var chartFragment = ChartFactory.CreateChart(ChartDescriptor, chartData);
        _chartFragments.Add(chartData.Id, chartFragment);
      }
    }
  }

  public async Task DeleteChart(string chartId)
  {
    // remove the fragment associated with the chart Id
    _chartFragments.Remove(chartId);

    // notify the parent
    await ChartDeleted.InvokeAsync(chartId);
  }
}