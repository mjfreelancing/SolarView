@foreach (var chartParameters in GetOrderedCharts())
{
  var chartId = chartParameters.ChartData.Id;

  <div @key="chartId">

    <div class="col col-12 d-flex">
      <span>@($"{chartParameters.ChartData.StartDate:yyyy-MM-dd}") - @($"{chartParameters.ChartData.EndDate:yyyy-MM-dd}")</span>
      <span class="oi oi-delete m-0 mt-1 ml-auto mr-4" @onclick="@(async () => await DeleteChart(chartId))"></span>
    </div>
    <DynamicComponent ComponentType="@ChartDescriptor.ChartType" Parameters="@(chartParameters.Parameters)" />

    @if (false)
    {
      <SfAccordion>
        <AccordionItems>
          <AccordionItem CssClass="chart-accordion-item" Expanded="true">
            <HeaderTemplate>
              <div class="col col-12 d-flex">
                <span>@($"{chartParameters.ChartData.StartDate:yyyy-MM-dd}") - @($"{chartParameters.ChartData.EndDate:yyyy-MM-dd}")</span>
                <span class="oi oi-delete m-0 mt-1 ml-auto mr-4" @onclick="@(async () => await DeleteChart(chartId))" @onclick:stopPropagation="StopPropagation"></span>
              </div>
            </HeaderTemplate>
            <ContentTemplate>
              <DynamicComponent ComponentType="@ChartDescriptor.ChartType" Parameters="@(chartParameters.Parameters)" />
            </ContentTemplate>
          </AccordionItem>
        </AccordionItems>
      </SfAccordion>
    }

  </div>
}

<style>
  /* force the content of each accordion header content to take up the full width */
  .chart-accordion-item .e-acrdn-header-content {
    width: 100%
  }
</style>

@code {
  [Parameter] public IChartDescriptor ChartDescriptor { get; set; }
  [Parameter] public IReadOnlyList<ChartData> ChartData { get; set; }
  [Parameter] public EventCallback<string> ChartDeleted { get; set; }

  private class ChartParameters
  {
    public ChartData ChartData { get; }   // mostly used for adding the charts in date order
    public IDictionary<string, object> Parameters { get; }

    public ChartParameters(ChartData chartData, IDictionary<string, object> parameters)
    {
      ChartData = chartData;

      Parameters = new Dictionary<string, object>(parameters)
    {
        {nameof(ChartData), chartData}
      };
    }
  }

  private const bool StopPropagation = true;
  private IReadOnlyList<ChartData> _chartData;
  private readonly IDictionary<string, ChartParameters> _renderedCharts = new Dictionary<string, ChartParameters>();

  private IReadOnlyCollection<ChartParameters> GetOrderedCharts()
  {
    return _renderedCharts.Values
      .OrderBy(item => item.ChartData.StartDate)
      .ThenBy(item => item.ChartData.EndDate)
      .AsReadOnlyCollection();
  }


  protected override void OnParametersSet()
  {
    base.OnParametersSet();

    // Cannot use OnInitialized() as ChartData will be updated when another chart is added/removed
    UpdateCharts();
  }

  private void UpdateCharts()
  {
    _chartData = ChartData;

    foreach (var chartData in _chartData)
    {
      if (!_renderedCharts.ContainsKey(chartData.Id))
      {
        AddChart(chartData);
      }
    }
  }

  private void AddChart(ChartData chartData)
  {
    var chartParameters = new ChartParameters(chartData, ChartDescriptor.Parameters);

    _renderedCharts.Add(chartData.Id, chartParameters);
  }

  private async Task DeleteChart(string chartId)
  {
    // remove the fragment associated with the chart Id
    _renderedCharts.Remove(chartId);

    // notify the parent
    await ChartDeleted.InvokeAsync(chartId);
  }
}
