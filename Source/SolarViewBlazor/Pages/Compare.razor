@page "/compare"
@inject ISolarViewService SolarViewService
@inject IChartDataCache ChartDataCache
@inject IAppState AppState

<h1>Average Power Data</h1>

@if (!_isLoaded)
{
	<em>Loading...</em>
}
else
{
	<div class="row mb-2">
		<SfDateRangePicker Min="@_siteStartDate" Max="@MaxEndDate" @bind-StartDate="@StartDate" @bind-EndDate="@EndDate"
											 ValueChanged="LoadDateRange" Placeholder="Add a new range" />
	</div>

	@if (_chartData.IsNullOrEmpty())
	{
		<p><em>Select a date range...</em></p>
	}
	else
	{
		<div class="row">
			@foreach (var chart in _chartData)
			{
				var chartId = chart.Id;

				<div class="col-xl-6 col-lg-6 col-md-6 col-sm-12 col-12">
					<PowerChart StartDate="@chart.StartDate" EndDate="@chart.EndDate" MaxWatts="@MaxWattValue" MinCost="@MinCostValue" MaxCost="@MaxCostValue"
											PowerData="@chart.Data" />
					<button type="button" class="btn btn-primary" @onclick="() => RemoveChart(chartId)">Remove</button>
				</div>
			}
		</div>
	}
}

@code {
	private bool _isLoaded;
	private readonly DateTime _siteStartDate = new DateTime(2020, 5, 9);
	private DateTime MaxEndDate => DateTime.Now.Date.AddDays(-1);                   // todo: make this site specific (local time)
	private IList<ChartData> _chartData;

	private double MaxWattValue { get; set; }
	private double MinCostValue { get; set; }
	private double MaxCostValue { get; set; }

	private DateTime? StartDate { get; set; }
	private DateTime? EndDate { get; set; }

	// Due to pre-rendering in Blazor Server you can't perform any JS interop until the OnAfterRender lifecycle method
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			if (AppState.CurrentSite == null)
			{
				throw new InvalidOperationException("Expected a current site to be loaded");
			}

			var chartCount = await ChartDataCache.GetCount(AppState.CurrentSite.SiteId);

			if (chartCount > 0)
			{
				_chartData = await ChartDataCache.GetData(AppState.CurrentSite.SiteId);
				NotifyChartsModified();
			}

			_isLoaded = true;
			StateHasChanged();
		}
	}

	private async Task LoadDateRange()
	{
		var startDate = StartDate.Value.AddHours(10);
		var endDate = EndDate.Value.AddHours(10);

		var powerData = (await SolarViewService.CollectData(AppState.CurrentSite.SiteId, startDate, endDate)).AsReadOnlyList();

		var chartData = new ChartData
		{
			Id = $"{Guid.NewGuid()}",
			StartDate = startDate,
			EndDate = endDate,
			Data = powerData
		};

		_chartData ??= new List<ChartData>();
		_chartData.Add(chartData);

		await ChartDataCache.Add(AppState.CurrentSite.SiteId, chartData);

		// indicate a new range can now be added
		StartDate = null;
		EndDate = null;

		NotifyChartsModified();
	}

	private async void RemoveChart(string chartId)
	{
		var chartData = _chartData.Single(item => item.Id == chartId);
		_chartData.Remove(chartData);

		await ChartDataCache.Remove(AppState.CurrentSite.SiteId, chartId);
		NotifyChartsModified();
	}

	private void RecalculateChartLimits()
	{
		if (_chartData.IsNullOrEmpty())
		{
			MaxWattValue = 0;
			MinCostValue = 0;
			MaxCostValue = 0;
		}
		else
		{
			var flattenedData = _chartData.SelectMany(item => item.Data).AsReadOnlyList();

			var maxWatts = flattenedData
				.SelectMany(item => new[] { item.Consumption, item.Purchased, item.SelfConsumption, item.FeedIn, item.Production })
				.Max();

			var minCost = flattenedData.Min(item => item.AdjustedCost);
			var maxCost = flattenedData.Max(item => item.NoSolarCost);

			MaxWattValue = (1 + Math.Floor(maxWatts / 500d)) * 500d;    // intervals of 500 on chart

			// todo: write a helper method for these calcs that takes the sign into account
			if (minCost > 0.0d)
			{
				MinCostValue = (1 + Math.Floor(minCost / 0.2d)) * 0.2d;     // intervals of 0.2 on chart
			}
			else
			{
				MinCostValue = -(1 + Math.Floor(-minCost / 0.2d)) * 0.2d;     // intervals of 0.2 on chart
			}


			MaxCostValue = (1 + Math.Floor(maxCost / 0.2d)) * 0.2d;     // intervals of 0.2 on chart
		}
	}

	private void NotifyChartsModified()
	{
		RecalculateChartLimits();
		StateHasChanged();
	}
}
