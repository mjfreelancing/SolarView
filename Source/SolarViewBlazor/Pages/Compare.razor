@page "/compare"
@using DateRange = SolarView.Common.Models.DateRange
@using AllOverIt.Helpers
@attribute [Authorize]
@implements IDisposable

<h1>Average Power Data</h1>

<SiteView>
  <Loading>
    <LoadingView />
  </Loading>
  <SiteAvailable>
    <div class="mb-4">
      <div class="row mb-2">
        <ChartDateSelector MinDate="@SiteViewModel.CurrentSite.StartDate.ParseSolarDate()"
                           MaxDate="@SiteViewModel.CurrentSite.LastRefreshDateTime.ParseSolarDateTime().AddDays(-1).Date"
                           OnApplyDateRange="@(async dateRange => await ApplyDateRange(dateRange))" />
      </div>

      @if (!_chartData.IsNullOrEmpty())
      {
        <div class="row mt-4">
          @foreach (var chart in _chartData)
          {
            var chartId = chart.Id;

            <div class="col-sm-12 col-xl-6">
              <PowerChart StartDate="@chart.StartDate" EndDate="@chart.EndDate" MaxWatts="@MaxWattValue" MinCost="@MinCostValue" MaxCost="@MaxCostValue"
                          PowerData="@chart.Data" />
              <button class="btn btn-outline-primary btn-width-medium mt-2" @onclick="() => RemoveChart(chartId)">Remove</button>
            </div>
          }
        </div>
      }
    </div>
  </SiteAvailable>
  <SiteNotAvailable>
    <p class="mt-4 mb-4">No data to display.</p>
    <a href="">You need to provide a Site Id</a>
  </SiteNotAvailable>
</SiteView>

@code {
  [Inject] private ISiteViewModel SiteViewModel { get; set; }
  [Inject] IEventAggregator EventAggregator { get; set; }
  [Inject] private ISolarViewService SolarViewService { get; set; }
  [Inject] private IChartDataCache ChartDataCache { get; set; }

  private IList<ChartData> _chartData;

  private double MaxWattValue { get; set; }
  private double MinCostValue { get; set; }
  private double MaxCostValue { get; set; }

  public void Dispose()
  {
    EventAggregator.Unsubscribe<SiteChanged>(HandleSiteChanged);
  }

  protected override void OnInitialized()
  {
    base.OnInitialized();

    EventAggregator.Subscribe<SiteChanged>(HandleSiteChanged);
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    await base.OnAfterRenderAsync(firstRender);

    if (firstRender)
    {
      if (SiteViewModel.CurrentSite != null)
      {
        await LoadCharts();
      }

      StateHasChanged();
    }
  }

  private async Task HandleSiteChanged(SiteChanged message)
  {
    if (SiteViewModel.CurrentSite != null)
    {
      await LoadCharts();
    }

    StateHasChanged();
  }

  private async Task LoadCharts()
  {
    _ = SiteViewModel.CurrentSite.WhenNotNull(nameof(SiteViewModel.CurrentSite));

    var chartCount = await ChartDataCache.GetCount(SiteViewModel.CurrentSite.SiteId);

    if (chartCount > 0)
    {
      _chartData = await ChartDataCache.GetData(SiteViewModel.CurrentSite.SiteId);
      UpdateChartLimits();
    }
  }

  private async void RemoveChart(string chartId)
  {
    var chartData = _chartData.Single(item => item.Id == chartId);
    _chartData.Remove(chartData);

    await ChartDataCache.Remove(SiteViewModel.CurrentSite.SiteId, chartId);
    UpdateChartLimits();
  }

  private void RecalculateChartLimits()
  {
    if (_chartData.IsNullOrEmpty())
    {
      MaxWattValue = 0;
      MinCostValue = 0;
      MaxCostValue = 0;
    }
    else
    {
      var flattenedData = _chartData.SelectMany(item => item.Data).AsReadOnlyList();

      var maxWatts = flattenedData
        .SelectMany(item => new[] { item.Consumption, item.Purchased, item.SelfConsumption, item.FeedIn, item.Production })
        .Max();

      var minCost = flattenedData.Min(item => item.AdjustedCost);
      var maxCost = flattenedData.Max(item => item.NoSolarCost);

      MaxWattValue = (1 + Math.Floor(maxWatts / 500d)) * 500d;    // intervals of 500 on chart

      // todo: write a helper method for these calcs that takes the sign into account
      if (minCost > 0.0d)
      {
        MinCostValue = Math.Floor(minCost / 0.2d) * 0.2d;     // intervals of 0.2 on chart
      }
      else
      {
        MinCostValue = -(1 + Math.Floor(-minCost / 0.2d)) * 0.2d;     // intervals of 0.2 on chart
      }


      MaxCostValue = (1 + Math.Floor(maxCost / 0.2d)) * 0.2d;     // intervals of 0.2 on chart
    }
  }

  private void UpdateChartLimits()
  {
    RecalculateChartLimits();
    StateHasChanged();
  }

  private async Task ApplyDateRange(DateRange dateRange)
  {
    var startDate = dateRange.StartDateTime;
    var endDate = dateRange.EndDateTime;

    var powerData = (await SolarViewService.CollectData(SiteViewModel.CurrentSite.SiteId, startDate, endDate)).AsReadOnlyList();

    var chartData = new ChartData
    {
      Id = $"{Guid.NewGuid()}",
      StartDate = startDate,
      EndDate = endDate,
      Data = powerData
    };

    _chartData ??= new List<ChartData>();
    _chartData.Add(chartData);

    await ChartDataCache.Add(SiteViewModel.CurrentSite.SiteId, chartData);

    UpdateChartLimits();
  }
}
